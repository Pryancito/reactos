//! Servicio de Auditor√≠a para ReactOS Rust
//! 
//! Servicio dedicado para manejar la auditor√≠a
//! y registro de eventos de seguridad.

use reactos_rust_security::*;
use std::collections::HashMap;

/// Funci√≥n principal del servicio de auditor√≠a
fn main() {
    println!("=== Servicio de Auditor√≠a - ReactOS Rust ===");
    
    // Inicializar gestor de seguridad
    if let Err(e) = init_security_manager() {
        eprintln!("Error inicializando gestor de seguridad: {}", e);
        return;
    }
    
    println!("Servicio de auditor√≠a inicializado");
    
    // Ejecutar demostraci√≥n del servicio de auditor√≠a
    run_audit_demonstration();
    
    // Mostrar estad√≠sticas de auditor√≠a
    if let Some(manager) = get_security_manager() {
        print_audit_statistics(manager);
    }
    
    println!("Servicio de auditor√≠a completado");
}

/// Ejecutar demostraci√≥n del servicio de auditor√≠a
fn run_audit_demonstration() {
    println!("\n=== Demostraci√≥n del Servicio de Auditor√≠a ===");
    
    // Demostrar diferentes tipos de auditor√≠a
    demonstrate_authentication_audit();
    demonstrate_authorization_audit();
    demonstrate_encryption_audit();
    demonstrate_system_audit();
    demonstrate_audit_analysis();
    
    println!("\n=== Demostraci√≥n Completada ===");
}

/// Demostrar auditor√≠a de autenticaci√≥n
fn demonstrate_authentication_audit() {
    println!("\n--- Demostrando Auditor√≠a de Autenticaci√≥n ---");
    
    // Simular eventos de autenticaci√≥n
    let auth_events = vec![
        ("admin", "admin123", "192.168.1.100", true),
        ("admin", "wrongpass", "192.168.1.101", false),
        ("user1", "password", "192.168.1.102", true),
        ("admin", "wrongpass", "192.168.1.100", false),
    ];
    
    for (username, password, ip, expected_success) in auth_events {
        match authenticate_user(username, password, ip) {
            Ok(result) => {
                println!("‚úÖ Evento de autenticaci√≥n registrado: {}", result.message);
                if !expected_success {
                    println!("   ‚ö†Ô∏è  Resultado inesperado: se esperaba fallo");
                }
            }
            Err(e) => {
                println!("‚ùå Evento de autenticaci√≥n registrado: {}", e);
                if expected_success {
                    println!("   ‚ö†Ô∏è  Resultado inesperado: se esperaba √©xito");
                }
            }
        }
    }
}

/// Demostrar auditor√≠a de autorizaci√≥n
fn demonstrate_authorization_audit() {
    println!("\n--- Demostrando Auditor√≠a de Autorizaci√≥n ---");
    
    // Simular eventos de autorizaci√≥n
    let authz_events = vec![
        ("admin", "system", "admin"),
        ("admin", "user", "manage"),
        ("user1", "files", "read"),
        ("user1", "system", "admin"),
    ];
    
    for (user_id, resource, action) in authz_events {
        match authorize_access(user_id, resource, action) {
            Ok(result) => {
                println!("‚úÖ Evento de autorizaci√≥n registrado: {}", result.message);
            }
            Err(e) => {
                println!("‚ùå Evento de autorizaci√≥n registrado: {}", e);
            }
        }
    }
}

/// Demostrar auditor√≠a de cifrado
fn demonstrate_encryption_audit() {
    println!("\n--- Demostrando Auditor√≠a de Cifrado ---");
    
    let test_data = b"Sensitive data for encryption audit";
    let key = b"audit_test_key";
    
    // Cifrar datos
    match encrypt_data(test_data, key) {
        Ok(encrypted) => {
            println!("‚úÖ Evento de cifrado registrado");
            println!("   Datos originales: {} bytes", test_data.len());
            println!("   Datos cifrados: {} bytes", encrypted.len());
            
            // Descifrar datos
            match decrypt_data(&encrypted, key) {
                Ok(decrypted) => {
                    println!("‚úÖ Evento de descifrado registrado");
                    println!("   Datos descifrados: {} bytes", decrypted.len());
                    
                    if test_data == decrypted.as_slice() {
                        println!("‚úÖ Integridad de datos verificada");
                    } else {
                        println!("‚ùå Error en la integridad de datos");
                    }
                }
                Err(e) => {
                    println!("‚ùå Error en descifrado: {}", e);
                }
            }
        }
        Err(e) => {
            println!("‚ùå Error en cifrado: {}", e);
        }
    }
}

/// Demostrar auditor√≠a del sistema
fn demonstrate_system_audit() {
    println!("\n--- Demostrando Auditor√≠a del Sistema ---");
    
    if let Some(manager) = get_security_manager() {
        // Simular eventos del sistema
        let system_events = vec![
            ("System startup", SecurityEventType::SystemAccess, SecuritySeverity::Low),
            ("Configuration change", SecurityEventType::ConfigurationChange, SecuritySeverity::Medium),
            ("Policy violation", SecurityEventType::PolicyViolation, SecuritySeverity::High),
            ("Intrusion attempt", SecurityEventType::IntrusionAttempt, SecuritySeverity::Critical),
        ];
        
        for (description, event_type, severity) in system_events {
            let event = SecurityEvent {
                event_id: manager.generate_event_id(),
                event_type,
                severity,
                timestamp: std::time::Instant::now(),
                source: "AuditService".to_string(),
                target: "System".to_string(),
                description: description.to_string(),
                details: HashMap::new(),
                user_id: None,
                session_id: None,
                ip_address: None,
                success: true,
            };
            
            manager.log_security_event(event);
            println!("üìù Evento del sistema registrado: {}", description);
        }
    }
}

/// Demostrar an√°lisis de auditor√≠a
fn demonstrate_audit_analysis() {
    println!("\n--- Demostrando An√°lisis de Auditor√≠a ---");
    
    if let Some(manager) = get_security_manager() {
        let events = manager.get_security_events();
        
        // An√°lisis por tipo de evento
        let mut event_type_counts = HashMap::new();
        for event in events {
            *event_type_counts.entry(event.event_type).or_insert(0) += 1;
        }
        
        println!("üìä An√°lisis por tipo de evento:");
        for (event_type, count) in event_type_counts {
            println!("   {:?}: {} eventos", event_type, count);
        }
        
        // An√°lisis por severidad
        let mut severity_counts = HashMap::new();
        for event in events {
            *severity_counts.entry(event.severity).or_insert(0) += 1;
        }
        
        println!("üìà An√°lisis por severidad:");
        for (severity, count) in severity_counts {
            println!("   {:?}: {} eventos", severity, count);
        }
        
        // An√°lisis de eventos exitosos vs fallidos
        let successful_events = events.iter().filter(|e| e.success).count();
        let failed_events = events.len() - successful_events;
        
        println!("‚úÖ An√°lisis de √©xito/fallo:");
        println!("   Eventos exitosos: {}", successful_events);
        println!("   Eventos fallidos: {}", failed_events);
        
        if events.len() > 0 {
            let success_rate = (successful_events as f64 / events.len() as f64) * 100.0;
            println!("   Tasa de √©xito: {:.2}%", success_rate);
        }
        
        // An√°lisis temporal (√∫ltimos eventos)
        let recent_events: Vec<_> = events.iter().rev().take(5).collect();
        println!("‚è∞ √öltimos 5 eventos:");
        for (i, event) in recent_events.iter().enumerate() {
            println!("   {}. [{}] {} - {}", 
                i + 1,
                format!("{:?}", event.severity),
                format!("{:?}", event.event_type),
                event.description
            );
        }
    }
}

/// Imprimir estad√≠sticas de auditor√≠a
fn print_audit_statistics(manager: &SecurityManager) {
    println!("\n=== Estad√≠sticas de Auditor√≠a ===");
    
    // Configuraci√≥n de auditor√≠a
    println!("üîç Configuraci√≥n de auditor√≠a:");
    println!("   Auditor√≠a habilitada: {}", manager.config.enable_audit);
    println!("   Nivel de auditor√≠a: {:?}", manager.config.audit_level);
    println!("   Retenci√≥n de logs: {} d√≠as", manager.config.log_retention_days);
    
    // Estad√≠sticas generales
    let events = manager.get_security_events();
    println!("üìä Estad√≠sticas generales:");
    println!("   Total de eventos: {}", events.len());
    
    // Estad√≠sticas por tipo de evento
    let mut event_type_counts = HashMap::new();
    for event in events {
        *event_type_counts.entry(event.event_type).or_insert(0) += 1;
    }
    
    println!("üìã Eventos por tipo:");
    for (event_type, count) in event_type_counts {
        println!("   {:?}: {} eventos", event_type, count);
    }
    
    // Estad√≠sticas por severidad
    let mut severity_counts = HashMap::new();
    for event in events {
        *severity_counts.entry(event.severity).or_insert(0) += 1;
    }
    
    println!("üö® Eventos por severidad:");
    for (severity, count) in severity_counts {
        println!("   {:?}: {} eventos", severity, count);
    }
    
    // Estad√≠sticas de √©xito/fallo
    let successful_events = events.iter().filter(|e| e.success).count();
    let failed_events = events.len() - successful_events;
    
    println!("‚úÖ Estad√≠sticas de √©xito/fallo:");
    println!("   Eventos exitosos: {}", successful_events);
    println!("   Eventos fallidos: {}", failed_events);
    
    if events.len() > 0 {
        let success_rate = (successful_events as f64 / events.len() as f64) * 100.0;
        println!("   Tasa de √©xito: {:.2}%", success_rate);
    }
    
    // An√°lisis de fuentes
    let mut source_counts = HashMap::new();
    for event in events {
        *source_counts.entry(&event.source).or_insert(0) += 1;
    }
    
    println!("üîç Eventos por fuente:");
    for (source, count) in source_counts {
        println!("   {}: {} eventos", source, count);
    }
    
    // An√°lisis de usuarios
    let mut user_counts = HashMap::new();
    for event in events {
        if let Some(user_id) = &event.user_id {
            *user_counts.entry(user_id).or_insert(0) += 1;
        }
    }
    
    if !user_counts.is_empty() {
        println!("üë• Eventos por usuario:");
        for (user_id, count) in user_counts {
            println!("   {}: {} eventos", user_id, count);
        }
    }
    
    // An√°lisis de IPs
    let mut ip_counts = HashMap::new();
    for event in events {
        if let Some(ip_address) = &event.ip_address {
            *ip_counts.entry(ip_address).or_insert(0) += 1;
        }
    }
    
    if !ip_counts.is_empty() {
        println!("üåê Eventos por IP:");
        for (ip_address, count) in ip_counts {
            println!("   {}: {} eventos", ip_address, count);
        }
    }
    
    // Recomendaciones de auditor√≠a
    println!("üí° Recomendaciones de auditor√≠a:");
    
    if !manager.config.enable_audit {
        println!("   ‚ö†Ô∏è  La auditor√≠a est√° deshabilitada - considera habilitarla para cumplimiento");
    }
    
    match manager.config.audit_level {
        AuditLevel::None => {
            println!("   ‚ö†Ô∏è  Nivel de auditor√≠a: None - considera habilitar auditor√≠a b√°sica");
        }
        AuditLevel::Minimal => {
            println!("   ‚ÑπÔ∏è  Nivel de auditor√≠a: Minimal - considera aumentar a Standard");
        }
        AuditLevel::Standard => {
            println!("   ‚úÖ Nivel de auditor√≠a: Standard - adecuado para la mayor√≠a de casos");
        }
        AuditLevel::Detailed => {
            println!("   ‚úÖ Nivel de auditor√≠a: Detailed - proporciona informaci√≥n detallada");
        }
        AuditLevel::Comprehensive => {
            println!("   ‚úÖ Nivel de auditor√≠a: Comprehensive - m√°ximo nivel de auditor√≠a");
        }
    }
    
    if manager.config.log_retention_days < 30 {
        println!("   ‚ö†Ô∏è  Retenci√≥n de logs: {} d√≠as - considera aumentar a 30 d√≠as m√≠nimo", manager.config.log_retention_days);
    }
    
    // Verificar eventos cr√≠ticos
    let critical_events = events.iter().filter(|e| e.severity == SecuritySeverity::Critical).count();
    if critical_events > 0 {
        println!("   üö® Hay {} eventos cr√≠ticos que requieren atenci√≥n inmediata", critical_events);
    }
    
    let high_events = events.iter().filter(|e| e.severity == SecuritySeverity::High).count();
    if high_events > 5 {
        println!("   ‚ö†Ô∏è  Hay {} eventos de alta severidad que requieren revisi√≥n", high_events);
    }
    
    // Verificar patrones sospechosos
    let failed_auth_events = events.iter()
        .filter(|e| e.event_type == SecurityEventType::Authentication && !e.success)
        .count();
    
    if failed_auth_events > 10 {
        println!("   ‚ö†Ô∏è  Hay {} eventos de autenticaci√≥n fallida - revisar posibles ataques", failed_auth_events);
    }
    
    let intrusion_events = events.iter()
        .filter(|e| e.event_type == SecurityEventType::IntrusionAttempt)
        .count();
    
    if intrusion_events > 0 {
        println!("   üö® Hay {} intentos de intrusi√≥n detectados", intrusion_events);
    }
}
