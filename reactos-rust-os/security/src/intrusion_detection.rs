//! Sistema de Detecci√≥n de Intrusiones para ReactOS Rust
//! 
//! Sistema dedicado para detectar y responder
//! a intentos de intrusi√≥n y amenazas de seguridad.

use reactos_rust_security::*;
use std::collections::HashMap;

/// Funci√≥n principal del sistema de detecci√≥n de intrusiones
fn main() {
    println!("=== Sistema de Detecci√≥n de Intrusiones - ReactOS Rust ===");
    
    // Inicializar gestor de seguridad
    if let Err(e) = init_security_manager() {
        eprintln!("Error inicializando gestor de seguridad: {}", e);
        return;
    }
    
    println!("Sistema de detecci√≥n de intrusiones inicializado");
    
    // Ejecutar demostraci√≥n del sistema de detecci√≥n de intrusiones
    run_intrusion_detection_demonstration();
    
    // Mostrar estad√≠sticas de detecci√≥n de intrusiones
    if let Some(manager) = get_security_manager() {
        print_intrusion_detection_statistics(manager);
    }
    
    println!("Sistema de detecci√≥n de intrusiones completado");
}

/// Ejecutar demostraci√≥n del sistema de detecci√≥n de intrusiones
fn run_intrusion_detection_demonstration() {
    println!("\n=== Demostraci√≥n del Sistema de Detecci√≥n de Intrusiones ===");
    
    // Demostrar diferentes tipos de detecci√≥n
    demonstrate_brute_force_detection();
    demonstrate_anomaly_detection();
    demonstrate_pattern_detection();
    demonstrate_threat_response();
    demonstrate_intrusion_analysis();
    
    println!("\n=== Demostraci√≥n Completada ===");
}

/// Demostrar detecci√≥n de ataques de fuerza bruta
fn demonstrate_brute_force_detection() {
    println!("\n--- Demostrando Detecci√≥n de Ataques de Fuerza Bruta ---");
    
    // Simular m√∫ltiples intentos de login fallidos
    let username = "admin";
    let ip_address = "192.168.1.100";
    let wrong_passwords = vec![
        "password", "123456", "admin", "root", "test",
        "guest", "user", "login", "pass", "secret"
    ];
    
    println!("üîç Simulando ataques de fuerza bruta desde {} para usuario {}", ip_address, username);
    
    for (i, password) in wrong_passwords.iter().enumerate() {
        match authenticate_user(username, password, ip_address) {
            Ok(result) => {
                println!("‚úÖ Intento {}: Autenticaci√≥n exitosa (inesperado)", i + 1);
            }
            Err(e) => {
                println!("‚ùå Intento {}: Autenticaci√≥n fallida: {}", i + 1, e);
                
                // Detectar patr√≥n de fuerza bruta
                if i >= 4 { // Despu√©s de 5 intentos fallidos
                    detect_brute_force_attack(username, ip_address, (i + 1) as u32);
                }
            }
        }
    }
}

/// Detectar ataque de fuerza bruta
fn detect_brute_force_attack(username: &str, ip_address: &str, attempt_count: u32) {
    println!("üö® ATAQUE DE FUERZA BRUTA DETECTADO!");
    println!("   Usuario objetivo: {}", username);
    println!("   IP atacante: {}", ip_address);
    println!("   N√∫mero de intentos: {}", attempt_count);
    println!("   Severidad: CR√çTICA");
    
    // Simular respuesta autom√°tica
    respond_to_brute_force_attack(username, ip_address);
}

/// Responder a ataque de fuerza bruta
fn respond_to_brute_force_attack(username: &str, ip_address: &str) {
    println!("üõ°Ô∏è  Ejecutando respuesta autom√°tica:");
    println!("   1. Bloqueando IP: {}", ip_address);
    println!("   2. Bloqueando cuenta: {}", username);
    println!("   3. Enviando alerta a administradores");
    println!("   4. Registrando evento cr√≠tico");
    
    // Simular bloqueo de IP
    block_ip_address(ip_address);
    
    // Simular bloqueo de cuenta
    block_user_account(username);
    
    // Simular env√≠o de alerta
    send_security_alert("Brute Force Attack", username, ip_address);
}

/// Demostrar detecci√≥n de anomal√≠as
fn demonstrate_anomaly_detection() {
    println!("\n--- Demostrando Detecci√≥n de Anomal√≠as ---");
    
    // Simular comportamiento normal vs an√≥malo
    let normal_ips = vec!["192.168.1.100", "192.168.1.101", "192.168.1.102"];
    let anomalous_ips = vec!["10.0.0.1", "172.16.0.1", "203.0.113.1"];
    
    println!("üîç Analizando patrones de acceso:");
    
    // Comportamiento normal
    for ip in normal_ips {
        println!("‚úÖ Acceso normal desde IP: {}", ip);
        analyze_access_pattern(ip, "normal");
    }
    
    // Comportamiento an√≥malo
    for ip in anomalous_ips {
        println!("‚ö†Ô∏è  Acceso an√≥malo detectado desde IP: {}", ip);
        analyze_access_pattern(ip, "anomalous");
        detect_anomalous_behavior(ip);
    }
}

/// Analizar patr√≥n de acceso
fn analyze_access_pattern(ip_address: &str, pattern_type: &str) {
    println!("   üìä Analizando patr√≥n de acceso desde {}", ip_address);
    println!("   üìà Tipo de patr√≥n: {}", pattern_type);
    
    match pattern_type {
        "normal" => {
            println!("   ‚úÖ Patr√≥n normal - sin amenazas detectadas");
        }
        "anomalous" => {
            println!("   ‚ö†Ô∏è  Patr√≥n an√≥malo - posible amenaza");
            println!("   üîç Caracter√≠sticas an√≥malas:");
            println!("      - IP externa no reconocida");
            println!("      - Horario de acceso inusual");
            println!("      - Frecuencia de acceso alta");
        }
        _ => {
            println!("   ‚ùì Patr√≥n desconocido - requiere an√°lisis");
        }
    }
}

/// Detectar comportamiento an√≥malo
fn detect_anomalous_behavior(ip_address: &str) {
    println!("üö® COMPORTAMIENTO AN√ìMALO DETECTADO!");
    println!("   IP sospechosa: {}", ip_address);
    println!("   Severidad: ALTA");
    
    // Simular respuesta autom√°tica
    respond_to_anomalous_behavior(ip_address);
}

/// Responder a comportamiento an√≥malo
fn respond_to_anomalous_behavior(ip_address: &str) {
    println!("üõ°Ô∏è  Ejecutando respuesta autom√°tica:");
    println!("   1. Monitoreando IP: {}", ip_address);
    println!("   2. Aumentando nivel de alerta");
    println!("   3. Registrando comportamiento sospechoso");
    println!("   4. Notificando a administradores");
    
    // Simular monitoreo aumentado
    increase_monitoring_level(ip_address);
    
    // Simular notificaci√≥n
    send_security_alert("Anomalous Behavior", "Unknown", ip_address);
}

/// Demostrar detecci√≥n de patrones
fn demonstrate_pattern_detection() {
    println!("\n--- Demostrando Detecci√≥n de Patrones ---");
    
    // Simular diferentes patrones de ataque
    let attack_patterns = vec![
        ("Port Scanning", vec!["22", "80", "443", "3389", "5900"]),
        ("Directory Traversal", vec!["../", "../../", "../../../"]),
        ("SQL Injection", vec!["' OR 1=1", "'; DROP TABLE", "UNION SELECT"]),
        ("XSS Attempt", vec!["<script>", "javascript:", "onload="]),
    ];
    
    for (pattern_name, patterns) in attack_patterns {
        println!("üîç Detectando patr√≥n: {}", pattern_name);
        
        for pattern in patterns {
            if detect_attack_pattern(pattern_name, pattern) {
                println!("üö® Patr√≥n de ataque detectado: {} - {}", pattern_name, pattern);
                respond_to_attack_pattern(pattern_name, pattern);
            } else {
                println!("‚úÖ Patr√≥n normal: {}", pattern);
            }
        }
    }
}

/// Detectar patr√≥n de ataque
fn detect_attack_pattern(pattern_type: &str, pattern: &str) -> bool {
    match pattern_type {
        "Port Scanning" => {
            // Simular detecci√≥n de escaneo de puertos
            pattern.parse::<u16>().is_ok() && pattern.parse::<u16>().unwrap() < 10000
        }
        "Directory Traversal" => {
            // Simular detecci√≥n de directory traversal
            pattern.contains("../")
        }
        "SQL Injection" => {
            // Simular detecci√≥n de SQL injection
            pattern.to_uppercase().contains("OR") || pattern.to_uppercase().contains("UNION")
        }
        "XSS Attempt" => {
            // Simular detecci√≥n de XSS
            pattern.contains("<script>") || pattern.contains("javascript:")
        }
        _ => false,
    }
}

/// Responder a patr√≥n de ataque
fn respond_to_attack_pattern(pattern_type: &str, pattern: &str) {
    println!("üõ°Ô∏è  Ejecutando respuesta a patr√≥n de ataque:");
    println!("   Tipo: {}", pattern_type);
    println!("   Patr√≥n: {}", pattern);
    
    match pattern_type {
        "Port Scanning" => {
            println!("   1. Bloqueando IP atacante");
            println!("   2. Aumentando monitoreo de red");
        }
        "Directory Traversal" => {
            println!("   1. Bloqueando solicitud maliciosa");
            println!("   2. Registrando intento de acceso no autorizado");
        }
        "SQL Injection" => {
            println!("   1. Bloqueando consulta maliciosa");
            println!("   2. Alertando a administradores de base de datos");
        }
        "XSS Attempt" => {
            println!("   1. Sanitizando entrada maliciosa");
            println!("   2. Bloqueando script malicioso");
        }
        _ => {
            println!("   1. Aplicando respuesta gen√©rica");
        }
    }
}

/// Demostrar respuesta a amenazas
fn demonstrate_threat_response() {
    println!("\n--- Demostrando Respuesta a Amenazas ---");
    
    // Simular diferentes tipos de amenazas
    let threats = vec![
        ("Malware Detection", "virus.exe", "CRITICAL"),
        ("Unauthorized Access", "admin", "HIGH"),
        ("Data Exfiltration", "sensitive_data.txt", "HIGH"),
        ("System Compromise", "rootkit", "CRITICAL"),
    ];
    
    for (threat_type, target, severity) in threats {
        println!("üö® AMENAZA DETECTADA: {}", threat_type);
        println!("   Objetivo: {}", target);
        println!("   Severidad: {}", severity);
        
        respond_to_threat(threat_type, target, severity);
    }
}

/// Responder a amenaza
fn respond_to_threat(_threat_type: &str, _target: &str, severity: &str) {
    println!("üõ°Ô∏è  Ejecutando respuesta a amenaza:");
    
    match severity {
        "CRITICAL" => {
            println!("   üö® RESPUESTA CR√çTICA:");
            println!("   1. Aislamiento inmediato del sistema");
            println!("   2. Bloqueo de todas las conexiones");
            println!("   3. Notificaci√≥n de emergencia");
            println!("   4. Activaci√≥n del protocolo de incidentes");
        }
        "HIGH" => {
            println!("   ‚ö†Ô∏è  RESPUESTA DE ALTA PRIORIDAD:");
            println!("   1. Bloqueo del objetivo espec√≠fico");
            println!("   2. Aumento del monitoreo");
            println!("   3. Notificaci√≥n a administradores");
            println!("   4. An√°lisis forense");
        }
        "MEDIUM" => {
            println!("   ‚ÑπÔ∏è  RESPUESTA EST√ÅNDAR:");
            println!("   1. Registro del evento");
            println!("   2. Monitoreo aumentado");
            println!("   3. Notificaci√≥n est√°ndar");
        }
        _ => {
            println!("   ‚ÑπÔ∏è  RESPUESTA B√ÅSICA:");
            println!("   1. Registro del evento");
            println!("   2. Monitoreo continuo");
        }
    }
}

/// Demostrar an√°lisis de intrusiones
fn demonstrate_intrusion_analysis() {
    println!("\n--- Demostrando An√°lisis de Intrusiones ---");
    
    if let Some(manager) = get_security_manager() {
        let events = manager.get_security_events();
        
        // An√°lisis de eventos de intrusi√≥n
        let intrusion_events: Vec<_> = events.iter()
            .filter(|e| e.event_type == SecurityEventType::IntrusionAttempt)
            .collect();
        
        println!("üîç An√°lisis de eventos de intrusi√≥n:");
        println!("   Total de eventos de intrusi√≥n: {}", intrusion_events.len());
        
        if !intrusion_events.is_empty() {
            // An√°lisis por severidad
            let mut severity_counts = HashMap::new();
            for event in &intrusion_events {
                *severity_counts.entry(event.severity).or_insert(0) += 1;
            }
            
            println!("   Eventos por severidad:");
            for (severity, count) in severity_counts {
                println!("     {:?}: {} eventos", severity, count);
            }
            
            // An√°lisis por fuente
            let mut source_counts = HashMap::new();
            for event in &intrusion_events {
                *source_counts.entry(&event.source).or_insert(0) += 1;
            }
            
            println!("   Eventos por fuente:");
            for (source, count) in source_counts {
                println!("     {}: {} eventos", source, count);
            }
            
            // An√°lisis temporal
            let recent_intrusions: Vec<_> = intrusion_events.iter().rev().take(3).collect();
            println!("   √öltimos 3 eventos de intrusi√≥n:");
            for (i, event) in recent_intrusions.iter().enumerate() {
                println!("     {}. [{}] {} - {}", 
                    i + 1,
                    format!("{:?}", event.severity),
                    event.source,
                    event.description
                );
            }
        }
        
        // An√°lisis de patrones de ataque
        analyze_attack_patterns(events);
        
        // An√°lisis de tendencias
        analyze_security_trends(events);
    }
}

/// Analizar patrones de ataque
fn analyze_attack_patterns(events: &[SecurityEvent]) {
    println!("üìä An√°lisis de patrones de ataque:");
    
    // Contar eventos por tipo
    let mut event_type_counts = HashMap::new();
    for event in events {
        *event_type_counts.entry(event.event_type).or_insert(0) += 1;
    }
    
    // Identificar patrones sospechosos
    let suspicious_patterns = vec![
        (SecurityEventType::Authentication, 10, "M√∫ltiples intentos de autenticaci√≥n fallida"),
        (SecurityEventType::Authorization, 5, "M√∫ltiples intentos de acceso no autorizado"),
        (SecurityEventType::IntrusionAttempt, 1, "Intento de intrusi√≥n detectado"),
    ];
    
    for (event_type, threshold, description) in suspicious_patterns {
        if let Some(count) = event_type_counts.get(&event_type) {
            if *count >= threshold {
                println!("   üö® Patr√≥n sospechoso detectado: {} ({} eventos)", description, count);
            } else {
                println!("   ‚úÖ Patr√≥n normal: {} ({} eventos)", description, count);
            }
        }
    }
}

/// Analizar tendencias de seguridad
fn analyze_security_trends(events: &[SecurityEvent]) {
    println!("üìà An√°lisis de tendencias de seguridad:");
    
    // An√°lisis por severidad
    let mut severity_counts = HashMap::new();
    for event in events {
        *severity_counts.entry(event.severity).or_insert(0) += 1;
    }
    
    let critical_events = severity_counts.get(&SecuritySeverity::Critical).unwrap_or(&0);
    let high_events = severity_counts.get(&SecuritySeverity::High).unwrap_or(&0);
    let medium_events = severity_counts.get(&SecuritySeverity::Medium).unwrap_or(&0);
    let low_events = severity_counts.get(&SecuritySeverity::Low).unwrap_or(&0);
    
    println!("   Eventos cr√≠ticos: {}", critical_events);
    println!("   Eventos de alta severidad: {}", high_events);
    println!("   Eventos de severidad media: {}", medium_events);
    println!("   Eventos de baja severidad: {}", low_events);
    
    // Evaluar tendencias
    if *critical_events > 0 {
        println!("   üö® TENDENCIA CR√çTICA: Hay eventos cr√≠ticos que requieren atenci√≥n inmediata");
    } else if *high_events > 5 {
        println!("   ‚ö†Ô∏è  TENDENCIA ALTA: Hay muchos eventos de alta severidad");
    } else if *medium_events > 10 {
        println!("   ‚ÑπÔ∏è  TENDENCIA MEDIA: Hay varios eventos de severidad media");
    } else {
        println!("   ‚úÖ TENDENCIA NORMAL: Nivel de seguridad dentro de par√°metros normales");
    }
}

/// Funciones auxiliares para simulaci√≥n

fn block_ip_address(ip_address: &str) {
    println!("   üîí IP {} bloqueada", ip_address);
}

fn block_user_account(username: &str) {
    println!("   üîí Cuenta {} bloqueada", username);
}

fn send_security_alert(alert_type: &str, username: &str, ip_address: &str) {
    println!("   üìß Alerta de seguridad enviada: {} - {} desde {}", alert_type, username, ip_address);
}

fn increase_monitoring_level(ip_address: &str) {
    println!("   üëÅÔ∏è  Nivel de monitoreo aumentado para IP: {}", ip_address);
}

/// Imprimir estad√≠sticas de detecci√≥n de intrusiones
fn print_intrusion_detection_statistics(manager: &SecurityManager) {
    println!("\n=== Estad√≠sticas de Detecci√≥n de Intrusiones ===");
    
    // Configuraci√≥n de detecci√≥n de intrusiones
    println!("üîç Configuraci√≥n de detecci√≥n de intrusiones:");
    println!("   Detecci√≥n de intrusiones habilitada: {}", manager.config.enable_intrusion_detection);
    
    // Estad√≠sticas de eventos de intrusi√≥n
    let events = manager.get_security_events();
    let intrusion_events: Vec<_> = events.iter()
        .filter(|e| e.event_type == SecurityEventType::IntrusionAttempt)
        .collect();
    
    println!("üìä Estad√≠sticas de eventos de intrusi√≥n:");
    println!("   Total de eventos de intrusi√≥n: {}", intrusion_events.len());
    
    if !intrusion_events.is_empty() {
        // An√°lisis por severidad
        let mut severity_counts = HashMap::new();
        for event in &intrusion_events {
            *severity_counts.entry(event.severity).or_insert(0) += 1;
        }
        
        println!("   Eventos por severidad:");
        for (severity, count) in severity_counts {
            println!("     {:?}: {} eventos", severity, count);
        }
        
        // An√°lisis de √©xito/fallo
        let successful_intrusions = intrusion_events.iter().filter(|e| e.success).count();
        let failed_intrusions = intrusion_events.len() - successful_intrusions;
        
        println!("   Intrusiones exitosas: {}", successful_intrusions);
        println!("   Intrusiones bloqueadas: {}", failed_intrusions);
        
        if intrusion_events.len() > 0 {
            let block_rate = (failed_intrusions as f64 / intrusion_events.len() as f64) * 100.0;
            println!("   Tasa de bloqueo: {:.2}%", block_rate);
        }
    }
    
    // Estad√≠sticas de eventos de autenticaci√≥n fallida
    let failed_auth_events: Vec<_> = events.iter()
        .filter(|e| e.event_type == SecurityEventType::Authentication && !e.success)
        .collect();
    
    println!("üîê Estad√≠sticas de autenticaci√≥n fallida:");
    println!("   Total de intentos fallidos: {}", failed_auth_events.len());
    
    if failed_auth_events.len() > 10 {
        println!("   ‚ö†Ô∏è  Alto n√∫mero de intentos fallidos - posible ataque de fuerza bruta");
    }
    
    // Estad√≠sticas de eventos de autorizaci√≥n fallida
    let failed_authz_events: Vec<_> = events.iter()
        .filter(|e| e.event_type == SecurityEventType::Authorization && !e.success)
        .collect();
    
    println!("üö´ Estad√≠sticas de autorizaci√≥n fallida:");
    println!("   Total de accesos denegados: {}", failed_authz_events.len());
    
    if failed_authz_events.len() > 5 {
        println!("   ‚ö†Ô∏è  Alto n√∫mero de accesos denegados - posible intento de escalaci√≥n");
    }
    
    // Recomendaciones de seguridad
    println!("üí° Recomendaciones de detecci√≥n de intrusiones:");
    
    if !manager.config.enable_intrusion_detection {
        println!("   ‚ö†Ô∏è  La detecci√≥n de intrusiones est√° deshabilitada - considera habilitarla");
    }
    
    if intrusion_events.len() > 0 {
        println!("   üö® Hay eventos de intrusi√≥n registrados - revisar y tomar medidas");
    }
    
    if failed_auth_events.len() > 20 {
        println!("   ‚ö†Ô∏è  Muchos intentos de autenticaci√≥n fallida - revisar pol√≠ticas de contrase√±as");
    }
    
    if failed_authz_events.len() > 10 {
        println!("   ‚ö†Ô∏è  Muchos accesos denegados - revisar permisos y roles");
    }
    
    // Verificar eventos cr√≠ticos
    let critical_events = events.iter().filter(|e| e.severity == SecuritySeverity::Critical).count();
    if critical_events > 0 {
        println!("   üö® Hay {} eventos cr√≠ticos que requieren atenci√≥n inmediata", critical_events);
    }
}
